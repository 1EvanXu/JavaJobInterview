
### 进程和线程的区别？

- 进程是操作系统资源分配的基本单位。每个进程都有独立的代码和数据空间，进程间的切换会有较大的开销
- 线程是CPU独立调度的基本单位。同一类线程共享代码和数据空间，每个线程有独立运行的运行栈和程序计数器，切换开销小。

### 如何理解上下文切换？

- 让步式上下文切换：执行程序主动释放CPU，与锁竞争严重程度成正比，可以通过使用无锁竞争和数据分段。
- 抢占式上下文切换：由于线程因分配的时间片被用尽被迫放弃CPU或者被其他优先级更高的线程锁抢占，一般由于线程数大于可用核心数引起，可以通过适量减少线程数避免

### Java线程和操作系统线程的关系？

JDK1.2之前，程序员们为JVM开发了自己的一个线程调度内核，而到操作系统层面就是用户空间内的线程实现。而到了JDK1.2之后，JVM选择了更加稳健且方便使用的操作系统原生的线程模型，通过系统调用将程序的线程交给了操作系统内核进行调度

### Java如何实现线程安全？

- 互斥同步：使用Synchronized或者ReentrantLock进行同步
- 非阻塞同步：需要硬件指令配合完成，CAS
- 无同步方案：将变量保存在本地线程，ThreadLocal

### Synchronized 和 ReentrantLock 的区别：

- Lock提供了Synchronized关键字所不具备的主要特性有：
    - 尝试非阻塞地获取锁
    - 获取锁的线程可以响应中断
    - 延时获取锁
- 前者是JVM提供的加锁，悲观锁；Lock是Java语言实现是乐观锁。

### 介绍一下Java里的锁？

**自旋锁**：自旋锁是在多处理器的条件下如果多个线程并行执行获取锁，后面请求的线程会进入一段自旋状态，看持有锁的线程是否很快会释放锁。在这个基础上引入自适应自旋，在自旋的基础上增加一个阈值，超过这个阈值线程就会被挂起，如果自旋刚刚成功过，那么就可以允许自旋等待更多次，如果经常不成功则下次会忽略自旋过程。

**偏向锁**：线程在第一次获取对象锁的过程中先会修改该锁对象的markdown记录线程ID，等到下一次进入的时候可以免去同步过程

**轻量级锁**：偏向锁存在竞争的时候会升级到轻量级锁，首先其它线程的竞争会使该对象的状态变更为未锁定状态，此时虚拟机会在当前线程的栈帧中建立一个锁记录并将该对象的markdown存入，然后尝试将对象的markdown更新为该锁记录的指针，如果成功则将对象的锁状态变成轻量级锁，如果失败了会检查是否是当前线程占有该锁。若是有两个以上的线程争用一个锁，则锁又会升级。

### 介绍一下volatile？

- volatile是Java用于保证变量读写可见性的关键字。遵循Happen-Before原则。内部的实现是在JVM层面上做的，通过禁止指令重排序，在volatile变量操作读之前加LoadLoad，读之后加LoadStore指令。写之前加StoreStore,写之后加StoreLoad。
- 使用volatile必须具备以下2个条件：
    1. 对变量的写操作不依赖于当前值
    2. 该变量没有包含在其他变量的不变式中
- 常用于多任务环境下各任务间共享的标志


### 死锁？

#### 死锁的发生条件？解决思路？

1. 互斥条件：资源是独占的，进程互斥使用
2. 不可剥夺条件：未用完之前不可强行剥夺
3. 请求和保持条件：申请新的资源的同时占有已分配资源
4. 循环等待条件：多个进程相互持有对方所需要的资源

#### 死锁预防：
1. 破坏“请求和保持条件”：在开始时资源一次性分配；
2. 破坏“不可剥夺条件”：当某进程新的资源未满足时释放已占有资源
3. 破坏“循环等待条件”：串行化申请资源


#### 死锁避免：

1. 避免一个线程同时获得多个锁
2. 避免一个线程在锁内同时占用多个资源
3. 使用定时锁

### 分布式环境下，如何保证线程安全？

避免并发、异步时间戳、串行化、全局唯一ID
    
##### 银行家算法


## 线程池

### 为什么要用线程池：

1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务
2. 可以根据系统的承受能力，调整线程池中工作线程的数目，防止消耗过多的内存

### 常见线程池：

1. **newSingleThreadPool**
    - 单线程化的线程池，开辟一个工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行

2. **newCacheThreadPool**
    - 可缓存的线程池，先看池中有没有以前建立的线程，没有再创建。当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程。通常用于生存期短的异步任务

3. **newFixedThreadPool(int n)**
    - 创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。

4. **newScheduledThreadPool(int n)**
    - 创建一个定长线程池，支持定时及周期性任务执行
    - 重要参数：
        - `corePoolSize`：核心池的大小，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
        - `maximumPoolSize`：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
        - `keepAliveTime`：表示线程没有任务执行时最多保持多久时间会终止。

