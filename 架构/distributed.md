### CAP理论
**CAP理论指的是，在分布式系统中的，一致性（Consistency），可用性（Available），分区容错性（Partition tolerance），三者不可兼得。**

该理论的的三个特性归纳如下：
- 一致性（C）：在分布式存储系统中的所有数据备份，同一时刻是否是同样的值。（等同于所有节点访问同一份最新数据副本）
- 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
- 分区容性（P）：以实际效果而言，分区相当于通信的时延要求。系统如果不能在时限内达成一项数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之前作出选择

### BASE理论
BASE理论是Basically Available（基本可用）、Solft state（软状态）和Eventually consistency（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其源于对大规模互联网系统分布式实践的结论，是基于CAP理论逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来达到最终一致性。

### 如何保证幂等性？
1. 使用全局性唯一ID
2. 采用类似[MVCC](../MySQL/MVCC.md)（多版本并发控制）之类的方法。
3. 采用Redis的分布式锁，全局查询的方式确保同一时间只有一个请求。

### 分布式事务策略
- 方案一：使用分布式数据库事务。
    - 优点：交由数据库处理，简单有效。
    - 缺点：性能代价高。
- 方案二：由应用程序和数据库共同控制
    - 原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。
    - 优点：性能上有优势。
    - 缺点：需要应用程序在事务控制上做灵活设计。

### 分布式缓存的使用场景
1. 页面静态资源css和图片缓存--电商类应用。
2. Session会话状态及应用横向扩展时的状态数据--游戏应用中玩家的热点数据。
3. 应用对象缓存--作为服务层的二级缓存减轻数据库的压力。
4. 事件缓存--针对事件的连续查询技术，满足实时性要求。

### 缓存击穿，缓存穿透，缓存雪崩
- **缓存穿透**：指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要击穿到后端数据库系统进行查询，使数据库压力过大，甚至使数据库服务被压死。
    - 解决方案：
        - 将空值缓存起来（为空值设置key），再次接收到同样的查询请求时，若命中缓存并且值为空，就会直接返回，不会透传到数据库，避免缓存击穿。
        - 对输入的参数进行过滤，可以拦截一定的无效请求。
- **缓存击穿**：通常在高并发的场景下，当一个缓存key过期时，因为访问这个缓存key的请求量较大，多个请求同时发现缓存过期，因此多个请求回同时访问数据库来查询最新数据，并写回缓存，这样回造成应用和数据库的负载增加，性能降低。由于并发较高，甚至回导致DB崩溃。
    - 解决方案：
        - 使用分布式锁，保证对每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很多。
        - 通过本地锁的方式来限制只有一个线程去数据库中查询数据，而其他线程只需等待，等前面的线程查询到数据后再访问缓存。但是，这种方法只能限制一个服务节点只有一个线程去数据库中查询，如果一个服务有多个节点，则还会有多个数据库查询操作，也就是说在节点数量较多的情况下并没有完全解决缓存并发的问题。
        - 软过期。对缓存中的数据设置失效时间，不使用缓存服务提供的过期时间，而是业务层在数据中存储过期时间信息，由业务程序判断是否过期并更新，在发现了`数据即将过期`时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。
- **缓存雪崩**：指的是缓存服务器重启或者大量缓存集中在同一时间段内失效，给后端数据库造成瞬时的负载升高，甚至压垮数据库的情况。
    - 解决方案：
        - 对不同的数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间，例如，要缓存user数据，会对每个用户的数据设置不同的缓存过期时间，可以定义一个基础时间，假设10秒，然后加上一个两秒以内的随机数，过期时间为10～12秒，就会避免缓存雪崩。

### [分布式锁原理和实现方式](distributed-lock.md)
#### 分布式锁应有的特性
- 在分布式部署的应用集群中，同一个方法只能被一台机器上的一个线程执行。
- 应该是可重用的锁。
- 有高可用的获取和释放锁的功能。
- 根据业务决定是否需要阻塞。
#### 常用的实现方案
1. 基于数据库实现（简单但有性能隐患）
    - 通过数据库的排他锁实现：如果连接多了且任务长时间不提交可能回把数据库的连接池撑爆。
    - 通过数据库中的表的记录存在的情况：存在单点故障，非重入的（*因为数据库中已经有数据了，可以在表中添加机器信息字段解决*）
2.  基于缓存实现（性能好但是不容易控制失效时间）
    - 可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如Tair的put方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。
3.  基于Zookeeper实现（比较可靠，性能稍弱于缓存）
    - 每个客户端对于某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个
#### 三种实现方案的比较 
- 从理解的难易程度角度（从低到高）：数据库 > 缓存 > Zookeeper
- 从实现的复杂性角度（从低到高）：Zookeeper >= 缓存 > 数据库
- 从性能角度（从高到低）：缓存 > Zookeeper >= 数据库
- 从可靠性角度（从高到低）：Zookeeper > 缓存 > 数据库





